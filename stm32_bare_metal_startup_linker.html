<!DOCTYPE HTML>
<html>
    <head>
        <title>JBV | STM32 Series</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <link rel="stylesheet" href="assets/css/main.css" />
        <meta name="author" content="John Bryan Valle" />
        <meta name="keywords" content="microcontrollers, electronics, software, hardware, developement, programming" />
        <link rel="icon" type="x-icon" href="favicon.ico">
        <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
    </head>
    <body class="is-preload">

        <!-- Page Wrapper -->
        <div id="page-wrapper">

            <!-- Header -->
            <header id="header" class="main-header">
                <style>
.box {
    width: 100%;
    height: 100%;
}
      img {
          width: 100%;
          height: 100%;
      }
                </style>
                <h1><a href="index.html">John Bryan Valle</a></h1>
                <!--<img src="images/jbv_logo.png" alt="Banner Image" />-->
                <nav id="nav">
                    <ul>
                        <li class="special">
                            <a href="#menu" class="menuToggle"><span>Menu</span></a>
                            <div id="menu">
                                <ul>
                                    <li><a href="index.html">About</a></li>
                                    <li><a href="projects.html">Projects</a></li>
                                    <li><a href="blog.html">Blog</a></li>
                                </ul>
                            </div>
                        </li>
                    </ul>
                </nav>
            </header>

            <!-- Main -->
            <article id="main">
                <header>
                    <h2>Bare Metal STM32</h2>
                    <p>Setting up Startup, linkerscript and Makefile</p>
                </header>


                <!-- START: OVERVIEW -->
                <section id="Overview" class="wrapper style5">
                    <div class="inner">
                        <header>
                            <!--<h5>Overview</h5>-->
                        </header>
                        <table class="alt">
                            <thead>
                                <tr>
                                    <th>Sections</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><a href="#intro_reg_lev">Introduction</td>
                                    <td>Introduction to bare-metal register-level programming of STM32</td>
                                </tr>
                                <tr>
                                    <td><a href="#Bitwise_operators">Bitwise Operators</td>
                                    <td>Basics of bitwise operators and compound operators</td>
                                </tr>
                                <tr>
                                    <td><a href="#arm-gnu-toolchain">ARM-GNU-Toolchain</td>
                                    <td>Explanation of GNU-Toolchain and on-chip debugging and flashing </td>
                                </tr>
                                <tr>
                                    <td><a href="#OpenOCD">OpenOCD</td>
                                    <td>Explanation debugging and flashing using OpenOCD</td>
                                </tr>
                                <tr>
                                    <td><a href="#linker_script">Linker Script</td>
                                    <td>Step-by-step walk through of a basic linker script for a STM32 board</td>
                                </tr>
                                <tr>
                                    <td><a href="#startup">Startup</td>
                                    <td>Step-by-step walk through of a basic startup file for a STM32 board</td>
                                </tr>
                                <tr>
                                    <td><a href="#makefile">Makefile</td>
                                    <td>Step-by-step walk through of a basic Makefile for a STM32 board</td>
                                </tr>
                                <tr>
                                    <td><a href="#blinky">Blinky-Project</td>
                                    <td>This section describes the register-level programming for creating a blink project</td>
                                </tr>
                                <tr>
                                    <td><a href="#share_repo">Code and Documentation</td>
                                    <td>Check out my code and documentation!</td>
                                </tr>
                            </tbody>
                        </table>

                        <!-- Markdown File Start -->

                        <h2 class="code-line" data-line-start=0 data-line-end=1><a id="intro_reg_lev"></a>Introduction</h2>
                        Suppose you’ve ever wondered how to set up a bare metal register level C program for developing embedded systems without an IDE or libraries such as HAL or any other abstractions. In that case, this blog post is for you! First, let’s define what register-level programming is and why you would want to use this approach.</br></br>
                        Register-level programming is  low-level programming where operations are carried out directly on the hardware registers of a processor. This is in contrast to the higher-level programming approach, which is done by applying modifications using abstractions such as functions and objects. There are numerous reasons why you would want to program at the register level:</br></br></br>

                        <ol>
                            <li>First, it can be very powerful, as it provides more precise control and flexibility over the hardware</li>
                            <li>Second, it can be used to create very efficient code, since you’re not dealing with the overhead of higher-level abstractions
                            </li>
                            <li>Third, it’s necessary for circumstances where operations must be performed that otherwise would be very difficult or even impossible at a higher level</li>
                            <li>And finally, IT CAN BE MORE FUN! :)
                            </li>
                        </ol>  

                        Still it’s important to keep some disadvantages in mind using this approach:</br></br>
                        <ol>
                            <li>First, it can be very difficult to debug register level code, as it is hard to read and follow the logic of the code,
                            </li>
                            <li>Second, it can be dangerous, as it’s easy to make mistakes and even damage the hardware</li>
                        </ol>  
                        Though register level programming can be difficult as it requires proficient knowledge about the hardware, it can be very rewarding as you can get maximum out of your embedded system.</br></br>

                        To get started some requirements are:</br>
                        1. A good development board, ie. from ST, Texas Instruments or Arduino, etc. (The board used in this example is STM32F401RE)</br>
                        2. A compiler and an assembler (The compiler used in this example is arm-none-eabi-gcc source: <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain" target="_blank">Click here</a>)</br></br>

                        These tools will allow us to write and compile code. Furthermore, register-level programming also requires knowledge of how to use bitwise operations. Bitwise operators perform bit-level modifications to integer-type values. Those operators are AND, OR, and XOR, which can be used to set, clear, toggle or invert individual bits. These operators can be very powerful, but also somewhat confusing. The following section provides a quick overview of the most important applications of these operators.</br></br>


                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="Bitwise_operators">Bitwise Operators</a></h2>

                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th>Operator</th>
                                    <th>Examples</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>ANDing</td>
                                    <td>0x2F & 0x10 = 0x20 // is used to clear individual bits
                                    </td>
                                </tr>
                                <tr>
                                    <td>ORing</td>
                                    <td>0x50 | 0x11 = 0x51 // is used to set individual bits
                                    </td>
                                </tr>
                                <tr>
                                    <td>XORing</td>
                                    <td>0x01 ^ 0x11 = 0x10 // is used to toggle individual bits</td>
                                </tr>
                                <tr>
                                    <td>Inverting / NOT</td>
                                    <td>~0x55 = 0xAA // is used to invert individual bits 
                                    </td>
                                </tr>
                                <tr>
                                    <td>Shift Left</td>
                                    <td>0b0001 << 3 = 0b1000 // 1 has shifted 3 positions to the left
                                    </td>
                                </tr>
                                <tr>
                                    <td>Shift Right</td>
                                    <td>0b1000 >> 3 = 0b0001 // 1 has shifted 3 positions to the write</td>
                                </tr>
                            </tbody>
                        </table>

                        <!--
                            <h1 class="code-line" data-line-start=23 data-line-end=24><a id="Required_Tools_23"></a>Required Tools</h1>
                            <h3 class="code-line" data-line-start=27 data-line-end=28><a id="Java_Runtime_Environment_27"></a>Java Runtime Environment</h3>
                        -->

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="arm-gnu-toolchain">ARM-GNU-Toolchain</a></h2>
                        The GNU Toolchain is a collection of programming tools produced by the GNU Project. It’s used to turn source code into executables.It is a powerful tool that is completely free and highly portable. It includes the GNU Compiler Collection (GCC), the GNU Debugger (GDB), and further binaries and tools that are well-maintained.</br>
                        The ARM GNU Toolchain is a collection of these tools specialized for ARM - Chips. The flow diagram below illustrates how the ARM-GNU Toolchain compiles source files into a finished executable.</br>
                        <div class="box">
                            <img src="images/arm-gnu-toolchain.png">
                        </div>

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="OpenOCD">OpenOCD</a></h2>
                        There are multiple ways for debugging and flashing the finished executable onto the chip, however, in this example, the free open-source on-chip debugger OpenOCD is used. The following flow diagram illustrates how OpenOCD flashes and debugs the executable on the chip.</br>
                        <div class="box">
                            <img src="images/arm-gnu-toolchain-flashing.png">
                        </div>

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="linker_script">Linker - Script</a></h2>
                        The purpose of the linker script is to link together various pieces of code and data to form a complete executable. Its role is to provide the necessary runtime environment for the system to function properly. In order to write a linker script the GNU linker script language is used, which is actually a subset of the C programming language.</br></br>
                        The linker itself is a program integrated in the GNU Compiler Collection (GCC), which utilizes the linker script to determine how to map the contents of an executable file into memory. It controls the memory layout of an executable, including where in memory the executable’s code and data are placed. Additionally, it controls the linking process itself.
                        A Linker Script contains multiple sections, the memory section the define various memories in the systems and their attributes. The attribute of a memory includes its size, its starting address, its type and its reading permissions. The actual documentation for those sections can be looked up in the official GNU Documentation. A snippet of the documentation describing the memory section is provided in the following image.</br></br>

                        <div class="box">
                            <img src="images/memory_sec_doc.png">
                            <figcaption>GNU Linker Documentation of Memory Section</figcaption>
                        </div>
                        The regions sections defines the various regions in the memories. A region is a contiguous block of memory with a specific purpose. For example, a region may be created for the code, data or stack. This sections tell the linker how to link the various pieces of code and data together. A snippet of the documentation describing the regions section is provided in the following image.
                        <div class="box">
                            <img src="images/regions_sec_doc.png">
                            <figcaption>GNU Linker Documentation of Region Section</figcaption>
                        </div>


                        </br>The following code contains the actual code of the linker script used in this example:
                        <div class="box">
                            <img src="images/Linker_script_memory.png">
                        </div>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>The code above defines</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:1] </td>
                                    <td>the first entry point of the microcontroller, the reset_handler which handles the main hardware and software initializations</td>
                                </tr>
                                <tr>
                                    <td>[Line:4]</td>
                                    <td>the top address of the stack, this is required by the manufacturer</td>
                                </tr>
                                <tr>
                                    <td>[Line:7]</td>
                                    <td>as well as the actual memory section. This section defines that RAM memory has read | write | execute rights, with a starting address at 0x20000000 with a total size of 96KB. Additionally FLASH is defined to have read | execute rights, with a starting address at 0x08000000 and a total size of 512KB. All these information is specific to the STM32F401RE microcontroller.</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="box">
                            <img src="images/linker_script_sections.png">
                        </div>


                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:2]</td>
                                    <td>This is the Region Section, which tells the linker which parts of the code should be linked together</td>
                                </tr>
                                <tr>
                                    <td>[Line:4]</td>
                                    <td>The Code Sections which are associated with the .isr_vector symbol will be linked together and placed in the FLASH memory</td>
                                </tr>
                                <tr>
                                    <td>[Line:9]</td>
                                    <td>The Code Sections associated with .text and .rodata are linked together, meaning the actual code and read only memory such as constants will be placed in the .text memory section in FLASH</td>
                                </tr>
                                <tr>
                                    <td>[Line:19]</td>
                                    <td>This Line writes the starting address of the .data section into the symbol _sidata, this is lated used to copy the data section from FLASH to RAM</td>
                                </tr>
                                <tr>
                                    <td>[Line:21]</td>
                                    <td>All .data sections, meaning all initialized global and local static variables will be placed in a united .data section. Line 29 tells the linker that during loading .data will be placed in the FLASH and later in the SRAM memory during runtime. Additionally _sdata and edata are initialized denoting the staring and ending address of .data, which are are lated used in the reset handler to copy data from FLASH to RAM.</td>
                                </tr>
                                <tr>
                                    <td>[Line:31]</td>
                                    <td>All .bss sections, meaning all uninitialized global and local variables will be linked together in a .bss section in SRAM. Additionally _sbss and ebss are initialized denoting the staring and ending address of .bss, which are are lated used in the reset handler to initialized previously uninitialized values with zero.</td>
                                </tr>
                            </tbody>
                        </table>


                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="startup">Startup File</a></h2>
                        The Startup File is the first piece of code that runs when an embedded system is turned on. It is responsible for initializing the hardware and software of a system. The startup file is typically written in C or assembly language. In this example, C language was used.</br></br>

                        The two main parts of a startup file is</br>
                        <ul>
                            <li>the vector table and</li>
                            <li>the startup code, defined in the Reset Handler</li>
                        </ul>

                        <h3 class="code-line" data-line-start=25 data-line-end=26><a id="startup">The Vector Table</a></h3>

                        The vector table is a table of pointers to the interrupt handler functions. 
                        In embedded systems, a vector table is a data structure that contains a list of pointers to functions that the processor can execute. The vector table is typically located at the beginning of memory and is used by the processor to determine which functions to execute when an interrupt occurs. When an interrupt occurs, the processor looks up the address of the function to execute in the vector table, and then branches to that address. This allows the processor to execute the correct function for the type of interrupt that occurred. The vector table is a critical part of an embedded system and must be carefully designed to ensure that the processor can correctly handle all types of interrupts that may occur.</br></br>

                        <h3 class="code-line" data-line-start=25 data-line-end=26><a id="startup">The Reset Handler</a></h3>

                        The startup code is the code that initializes the hardware and software of the system.</br></br>
                        One of the most common ways to reset an embedded system today is through the use of a reset handler. A reset handler is a piece of code that is executed when the system is reset. This code can perform any necessary actions to ensure that the system is brought back to a known state. One common use for a reset handler is to initialize all of the hardware and software components of the system. This ensures that everything is in a known state when the system starts up again. Reset handlers can also be used to perform other tasks such as logging the reset event or sending a notification to a remote monitoring system. The main tasks of a Reset Handler implemented in this example are:</br></br>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th>Task</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Copy Data from flash to ram</td>
                                    <td>All data sections meaning all initialized global and local static data will usually be flashed onto the flash memory first. As data is part of the systems working memory, it has to be copied to the RAM to be able to apply read and write instructions to that memory.</td>
                                </tr>
                                <tr>
                                    <td>Initialize the bss section with zeroes</td>
                                    <td> The BSS section contains all uninitialized data. Therefore all its containing values will be assigned with zeroes</td>
                                </tr>
                                <tr>
                                    <td>Call main function</td>
                                    <td>The actual main entry point of the program will be called</td>
                                </tr>
                            </tbody>
                        </table> 

                        </br>The following code contains the actual code of the startup file used in this example:
                        <div class="box">
                            <img src="images/prototypes.png">
                        </div>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:2-7]</td>
                                    <td>Here the symbol names taken from the linker script are initialized. These will later be used in the reset handler.</td>
                                </tr>
                                <tr>
                                    <td>[Line:10-20] </td>
                                    <td>The prototypes used to call main as well as the interrupt handlers of the microcontroller are initialized. These are documented in Reference Manual of the STM32F401RE. If the Interrupt Handlers are not initialized with a customized Handler, a default handler will be called instead.</td>
                                </tr>
                            </tbody>
                        </table>


                        <div class="box">
                            <img src="images/vector_table.png">
                        </div>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:2]</td>
                                    <td>Here the array of function pointers are initialized using the section attribute. This will tell the compiler to place the array in the .isr_vector memory section in FLASH.</td>
                                </tr>
                            </tbody>
                        </table>


                        <div class="box">
                            <img src="images/reset_handler.png">
                        </div>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:4-5]</td>
                                    <td>Here pSRC is assigned the starting address of data and pDST is assigned the ending address of data. Notice that an ampersand symbol is used for the symbols. This is due to the fact that the symbols _sidata and _sdata are not usual variables but symbols created in the linker script. In order access their value an Ampersand is needed.</td>
                                </tr>
                                <tr>
                                    <td>[Line:7-10]</td>
                                    <td>Each Value of .data in the RAM memory is overwritten with the values from .data in FLASH, thereby copying .data from FLASH to RAM.</td>
                                </tr>
                                <tr>
                                    <td>[Line:12-14]</td>
                                    <td>All values of the bss section are assigned with zeroes.</td>
                                </tr>
                                <tr>
                                    <td>[Line:10-23]</td>
                                    <td>An endless loop, that will be entered ones an interrupt handler is called which has not been initialized. This is a common method to set up a basic program without having to define each handler.</td>
                                </tr>
                            </tbody>
                        </table>

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="Makefile">Makefile</a></h2>

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="blinky">Blinky - Project</a></h2>
                        <div class="box">
                            <img src="images/simple_blink_proj_main.png">
                        </div>

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="share_repo">Code and Documentation</a></h2>
                        If you're interested in seeing how this project was made, please check out the source code and documentation. All the code is available for you to view, and the documentation goes into detail about how everything works. Thanks for your interest!</br></br>

                        <div class="col-12" >
                            <ul class="actions">
                                <li><a href="https://github.com/jbvalle/011_bare_metal_STM32F401RE_basic_setup" target="_blank" class="button primary">Github</a></li>
                                <li><a href="https://jbvalle.github.io/011_bare_metal_STM32F401RE_basic_setup/" target="_blank" class="button">Documentation</a></li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Footer -->
                <footer id="footer">
                    <ul class="icons">
                        <li><a href="https://twitter.com/JbvalleJv" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
                        <li><a href="https://www.linkedin.com/in/johnbryanvalle/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
                        <li><a href="https://github.com/jbvalle" class="icon brands fa-github"><span class="label">Github</span></a></li>
                        <li><a href="mailto:jbvalle.jv@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
                    </ul>
                    <ul class="copyright">
                        <li>&copy; John Bryan Valle</li>
                    </ul>
                </footer>

        </div>

        <!-- Scripts -->
        <script src="assets/js/jquery.min.js"></script>
        <script src="assets/js/jquery.scrollex.min.js"></script>
        <script src="assets/js/jquery.scrolly.min.js"></script>
        <script src="assets/js/browser.min.js"></script>
        <script src="assets/js/breakpoints.min.js"></script>
        <script src="assets/js/util.js"></script>
        <script src="assets/js/main.js"></script>


    </body>




</html>
