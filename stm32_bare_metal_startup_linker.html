<!DOCTYPE HTML>
<html>
    <head>
        <title>JBV | STM32 Series</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <link rel="stylesheet" href="assets/css/main.css" />
        <meta name="author" content="John Bryan Valle" />
        <meta name="keywords" content="microcontrollers, electronics, software, hardware, developement, programming" />
        <link rel="icon" type="x-icon" href="favicon.ico">
        <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
    </head>
    <body class="is-preload">

        <!-- Page Wrapper -->
        <div id="page-wrapper">

            <!-- Header -->
            <header id="header" class="main-header">
                <style>
.box {
    width: 100%;
    height: 100%;
}
      img {
          width: 100%;
          height: 100%;
      }
                </style>
<style>
.alert {
  padding: 20px;
  background-color: #F4BC1C;
  color: white;
}

.closebtn {
  margin-left: 15px;
  color: white;
  font-weight: bold;
  float: right;
  font-size: 22px;
  line-height: 20px;
  cursor: pointer;
  transition: 0.3s;
}

.closebtn:hover {
  color: black;
}
</style>
                <h1><a href="index.html">John Bryan Valle</a></h1>
                <!--<img src="images/jbv_logo.png" alt="Banner Image" />-->
                <nav id="nav">
                    <ul>
                        <li class="special">
                            <a href="#menu" class="menuToggle"><span>Menu</span></a>
                            <div id="menu">
                                <ul>
                                    <li><a href="index.html">About</a></li>
                                    <li><a href="projects.html">Projects</a></li>
                                    <li><a href="blog.html">Blog</a></li>
                                </ul>
                            </div>
                        </li>
                    </ul>
                </nav>
            </header>

            <!-- Main -->
            <article id="main">
                <header>
                    <h2>Bare Metal STM32</h2>
                    <p>Setting up Startup, linkerscript and Makefile</p>
                </header>


                <!-- START: OVERVIEW -->
                <section id="Overview" class="wrapper style5">
                    <div class="inner">
                        <header>
                            <!--<h5>Overview</h5>-->
                        </header>
                        <table class="alt">
                            <thead>
                                <tr>
                                    <th>Sections</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><a href="#intro_reg_lev">Introduction</td>
                                    <td>Introduction to bare-metal register-level programming of STM32</td>
                                </tr>
                                <tr>
                                    <td><a href="#Bitwise_operators">Bitwise Operators</td>
                                    <td>Basics of bitwise operators and compound operators</td>
                                </tr>
                                <tr>
                                    <td><a href="#arm-gnu-toolchain">ARM-GNU-Toolchain</td>
                                    <td>Explanation of GNU-Toolchain and on-chip debugging and flashing </td>
                                </tr>
                                <tr>
                                    <td><a href="#OpenOCD">OpenOCD</td>
                                    <td>Explanation debugging and flashing using OpenOCD</td>
                                </tr>
                                <tr>
                                    <td><a href="#linker_script">Linker Script</td>
                                    <td>Step-by-step walk through of a basic linker script for a STM32 board</td>
                                </tr>
                                <tr>
                                    <td><a href="#startup">Startup</td>
                                    <td>Step-by-step walk through of a basic startup file for a STM32 board</td>
                                </tr>
                                <tr>
                                    <td><a href="#makefile">Makefile</td>
                                    <td>Step-by-step walk through of a basic Makefile for a STM32 board</td>
                                </tr>
                                <tr>
                                    <td><a href="#blinky">Blinky-Project</td>
                                    <td>This section describes the register-level programming for creating a blink project</td>
                                </tr>
                                <tr>
                                    <td><a href="#share_repo">Code and Documentation</td>
                                    <td>Check out my code and documentation!</td>
                                </tr>
                            </tbody>
                        </table>

                        <!-- Markdown File Start -->

                        <h2 class="code-line" data-line-start=0 data-line-end=1><a id="intro_reg_lev"></a>Introduction</h2>
                        Suppose you’ve ever wondered how to set up a bare metal register level C program for developing embedded systems without an IDE or libraries such as HAL or any other abstractions. In that case, this blog post is for you! First, let’s define what register-level programming is and why you would want to use this approach.</br></br>
                        Register-level programming is  low-level programming where operations are carried out directly on the hardware registers of a processor. This is in contrast to the higher-level programming approach, which is done by applying modifications using abstractions such as functions and objects. There are numerous reasons why you would want to program at the register level:</br></br></br>

                        <ol>
                            <li>First, it can be very powerful, as it provides more precise control and flexibility over the hardware</li>
                            <li>Second, it can be used to create very efficient code, since you’re not dealing with the overhead of higher-level abstractions
                            </li>
                            <li>Third, it’s necessary for circumstances where operations must be performed that otherwise would be very difficult or even impossible at a higher level</li>
                            <li>And finally, IT CAN BE MORE FUN! :)
                            </li>
                        </ol>  

                        Still it’s important to keep some disadvantages in mind using this approach:</br></br>
                        <ol>
                            <li>First, it can be very difficult to debug register level code, as it is hard to read and follow the logic of the code,
                            </li>
                            <li>Second, it can be dangerous, as it’s easy to make mistakes and even damage the hardware</li>
                        </ol>  
                        Though register level programming can be difficult as it requires proficient knowledge about the hardware, it can be very rewarding as you can get maximum out of your embedded system.</br></br>

                        To get started some requirements are:</br>
                        1. A good development board, ie. from ST, Texas Instruments or Arduino, etc. (The board used in this example is STM32F401RE)</br>
                        2. A compiler and an assembler (The compiler used in this example is arm-none-eabi-gcc source: <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain" target="_blank">Click here</a>)</br></br>

                        These tools will allow us to write and compile code. Furthermore, register-level programming also requires knowledge of how to use bitwise operations. Bitwise operators perform bit-level modifications to integer-type values. Those operators are AND, OR, and XOR, which can be used to set, clear, toggle or invert individual bits. These operators can be very powerful, but also somewhat confusing. The following section provides a quick overview of the most important applications of these operators.</br></br>


                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="Bitwise_operators">Bitwise Operators</a></h2>

                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th>Operator</th>
                                    <th>Examples</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>ANDing</td>
                                    <td>0x2F & 0x10 = 0x20 // is used to clear individual bits
                                    </td>
                                </tr>
                                <tr>
                                    <td>ORing</td>
                                    <td>0x50 | 0x11 = 0x51 // is used to set individual bits
                                    </td>
                                </tr>
                                <tr>
                                    <td>XORing</td>
                                    <td>0x01 ^ 0x11 = 0x10 // is used to toggle individual bits</td>
                                </tr>
                                <tr>
                                    <td>Inverting / NOT</td>
                                    <td>~0x55 = 0xAA // is used to invert individual bits 
                                    </td>
                                </tr>
                                <tr>
                                    <td>Shift Left</td>
                                    <td>0b0001 << 3 = 0b1000 // 1 has shifted 3 positions to the left
                                    </td>
                                </tr>
                                <tr>
                                    <td>Shift Right</td>
                                    <td>0b1000 >> 3 = 0b0001 // 1 has shifted 3 positions to the write</td>
                                </tr>
                            </tbody>
                        </table>

                        <!--
                            <h1 class="code-line" data-line-start=23 data-line-end=24><a id="Required_Tools_23"></a>Required Tools</h1>
                            <h3 class="code-line" data-line-start=27 data-line-end=28><a id="Java_Runtime_Environment_27"></a>Java Runtime Environment</h3>
                        -->

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="arm-gnu-toolchain">ARM-GNU-Toolchain</a></h2>
                        The GNU Toolchain is a collection of programming tools produced by the GNU Project. It’s used to turn source code into executables.It is a powerful tool that is completely free and highly portable. It includes the GNU Compiler Collection (GCC), the GNU Debugger (GDB), and further binaries and tools that are well-maintained.</br>
                        The ARM GNU Toolchain is a collection of these tools specialized for ARM - Chips. The flow diagram below illustrates how the ARM-GNU Toolchain compiles source files into a finished executable.</br>
                        <div class="box">
                            <img src="images/arm-gnu-toolchain.png">
                        </div>

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="OpenOCD">OpenOCD</a></h2>
                        There are multiple ways for debugging and flashing the finished executable onto the chip, however, in this example, the free open-source on-chip debugger OpenOCD is used. The following flow diagram illustrates how OpenOCD flashes and debugs the executable on the chip.</br>
                        <div class="box">
                            <img src="images/arm-gnu-toolchain-flashing.png">
                        </div>
                        OpenOCD needs scripts for the target(ie. microcontroller) and interface(ie. debugger) because it uses an embedded debugger to communicate with the target device. The debugger needs to know how to interface with the target device in order to properly communicate with it. The scripts provide this information to the debugger. The following code will later be used in order to debug and flash the program onto the microcontroller.
                        <pre>
                            <code>$ openocd -f /usr/share/openocd/scripts/interface/stlink-v2.cfg -f /usr/share/openocd/scripts/target/stm32f4x.cfg</code>
                        </pre>

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="linker_script">Linker - Script</a></h2>
                        The purpose of the linker script is to link together various pieces of code and data to form a complete executable. Its role is to provide the necessary runtime environment for the system to function properly. In order to write a linker script the GNU linker script language is used, which is actually a subset of the C programming language.</br></br>
                        The linker itself is a program integrated in the GNU Compiler Collection (GCC), which utilizes the linker script to determine how to map the contents of an executable file into memory. It controls the memory layout of an executable, including where in memory the executable’s code and data are placed. Additionally, it controls the linking process itself.
                        A Linker Script contains multiple sections, the memory section the define various memories in the systems and their attributes. The attribute of a memory includes its size, its starting address, its type and its reading permissions. The actual documentation for those sections can be looked up in the official GNU Documentation. A snippet of the documentation describing the memory section is provided in the following image.</br></br>

                        <div class="box">
                            <img src="images/memory_sec_doc.png">
                            <figcaption>GNU Linker Documentation of Memory Section</figcaption>
                        </div>
                        The regions sections defines the various regions in the memories. A region is a contiguous block of memory with a specific purpose. For example, a region may be created for the code, data or stack. This sections tell the linker how to link the various pieces of code and data together. A snippet of the documentation describing the regions section is provided in the following image.
                        <div class="box">
                            <img src="images/regions_sec_doc.png">
                            <figcaption>GNU Linker Documentation of Region Section</figcaption>
                        </div>


                        <h5>The following code contains the actual code of the linker script used in this example</h5>

                        <div class="box">
                            <img src="images/Linker_script_memory.png">
                        </div>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>The code above defines</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:1] </td>
                                    <td>the first entry point of the microcontroller, the reset_handler which handles the main hardware and software initializations</td>
                                </tr>
                                <tr>
                                    <td>[Line:4]</td>
                                    <td>the top address of the stack, this is required by the manufacturer</td>
                                </tr>
                                <tr>
                                    <td>[Line:7]</td>
                                    <td>as well as the actual memory section. This section defines that RAM memory has read | write | execute rights, with a starting address at 0x20000000 with a total size of 96KB. Additionally FLASH is defined to have read | execute rights, with a starting address at 0x08000000 and a total size of 512KB. All these information is specific to the STM32F401RE microcontroller.</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="box">
                            <img src="images/linker_script_sections.png">
                        </div>


                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:2]</td>
                                    <td>This is the Region Section, which tells the linker which parts of the code should be linked together</td>
                                </tr>
                                <tr>
                                    <td>[Line:4]</td>
                                    <td>The Code Sections which are associated with the .isr_vector symbol will be linked together and placed in the FLASH memory</td>
                                </tr>
                                <tr>
                                    <td>[Line:9]</td>
                                    <td>The Code Sections associated with .text and .rodata are linked together, meaning the actual code and read only memory such as constants will be placed in the .text memory section in FLASH</td>
                                </tr>
                                <tr>
                                    <td>[Line:19]</td>
                                    <td>This Line writes the starting address of the .data section into the symbol _sidata, this is lated used to copy the data section from FLASH to RAM</td>
                                </tr>
                                <tr>
                                    <td>[Line:21]</td>
                                    <td>All .data sections, meaning all initialized global and local static variables will be placed in a united .data section. Line 29 tells the linker that during loading .data will be placed in the FLASH and later in the SRAM memory during runtime. Additionally _sdata and edata are initialized denoting the staring and ending address of .data, which are are lated used in the reset handler to copy data from FLASH to RAM.</td>
                                </tr>
                                <tr>
                                    <td>[Line:31]</td>
                                    <td>All .bss sections, meaning all uninitialized global and local variables will be linked together in a .bss section in SRAM. Additionally _sbss and ebss are initialized denoting the staring and ending address of .bss, which are are lated used in the reset handler to initialized previously uninitialized values with zero.</td>
                                </tr>
                            </tbody>
                        </table>


                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="startup">Startup File</a></h2>
                        The Startup File is the first piece of code that runs when an embedded system is turned on. It is responsible for initializing the hardware and software of a system. The startup file is typically written in C or assembly language. In this example, C language was used.</br></br>

                        The two main parts of a startup file is</br>
                        <ul>
                            <li>the vector table and</li>
                            <li>the startup code, defined in the Reset Handler</li>
                        </ul>

                        <h3 class="code-line" data-line-start=25 data-line-end=26><a id="startup">The Vector Table</a></h3>

                        The vector table is a table of pointers to the interrupt handler functions. 
                        In embedded systems, a vector table is a data structure that contains a list of pointers to functions that the processor can execute. The vector table is typically located at the beginning of memory and is used by the processor to determine which functions to execute when an interrupt occurs. When an interrupt occurs, the processor looks up the address of the function to execute in the vector table, and then branches to that address. This allows the processor to execute the correct function for the type of interrupt that occurred. The vector table is a critical part of an embedded system and must be carefully designed to ensure that the processor can correctly handle all types of interrupts that may occur.</br></br>

                        <h3 class="code-line" data-line-start=25 data-line-end=26><a id="startup">The Reset Handler</a></h3>

                        The startup code is the code that initializes the hardware and software of the system.</br></br>
                        One of the most common ways to reset an embedded system today is through the use of a reset handler. A reset handler is a piece of code that is executed when the system is reset. This code can perform any necessary actions to ensure that the system is brought back to a known state. One common use for a reset handler is to initialize all of the hardware and software components of the system. This ensures that everything is in a known state when the system starts up again. Reset handlers can also be used to perform other tasks such as logging the reset event or sending a notification to a remote monitoring system. The main tasks of a Reset Handler implemented in this example are:</br></br>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th>Task</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Copy Data from flash to ram</td>
                                    <td>All data sections meaning all initialized global and local static data will usually be flashed onto the flash memory first. As data is part of the systems working memory, it has to be copied to the RAM to be able to apply read and write instructions to that memory.</td>
                                </tr>
                                <tr>
                                    <td>Initialize the bss section with zeroes</td>
                                    <td> The BSS section contains all uninitialized data. Therefore all its containing values will be assigned with zeroes</td>
                                </tr>
                                <tr>
                                    <td>Call main function</td>
                                    <td>The actual main entry point of the program will be called</td>
                                </tr>
                            </tbody>
                        </table> 


                        <h5>The following code contains the actual code of the linker script used in this example</h5>
                        <div class="box">
                            <img src="images/prototypes.png">
                        </div>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:2-7]</td>
                                    <td>Here the symbol names taken from the linker script are initialized. These will later be used in the reset handler.</td>
                                </tr>
                                <tr>
                                    <td>[Line:10-20] </td>
                                    <td>The prototypes used to call main as well as the interrupt handlers of the microcontroller are initialized. These are documented in Reference Manual of the STM32F401RE. If the Interrupt Handlers are not initialized with a customized Handler, a default handler will be called instead.</td>
                                </tr>
                            </tbody>
                        </table>


                        <div class="box">
                            <img src="images/vector_table.png">
                        </div>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:2]</td>
                                    <td>Here the array of function pointers are initialized using the section attribute. This will tell the compiler to place the array in the .isr_vector memory section in FLASH.</td>
                                </tr>
                            </tbody>
                        </table>


                        <div class="box">
                            <img src="images/reset_handler.png">
                        </div>
                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:4-5]</td>
                                    <td>Here pSRC is assigned the starting address of data and pDST is assigned the ending address of data. Notice that an ampersand symbol is used for the symbols. This is due to the fact that the symbols _sidata and _sdata are not usual variables but symbols created in the linker script. In order access their value an Ampersand is needed.</td>
                                </tr>
                                <tr>
                                    <td>[Line:7-10]</td>
                                    <td>Each Value of .data in the RAM memory is overwritten with the values from .data in FLASH, thereby copying .data from FLASH to RAM.</td>
                                </tr>
                                <tr>
                                    <td>[Line:12-14]</td>
                                    <td>All values of the bss section are assigned with zeroes.</td>
                                </tr>
                                <tr>
                                    <td>[Line:10-23]</td>
                                    <td>An endless loop, that will be entered ones an interrupt handler is called which has not been initialized. This is a common method to set up a basic program without having to define each handler.</td>
                                </tr>
                            </tbody>
                        </table>

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="makefile">Makefile</a></h2>
                        A makefile is a file that contains a set of instructions that tell a computer how to compile and link a program. In embedded systems, a makefile is often used to build a firmware image. A firmware image is a binary file that contains all of the code and data necessary to run a piece of hardware. In embedded systems, this binary file is often stored in flash memory. When you create a new project, you will typically start with a blank makefile. </br></br></br>

                        <h5>The following code contains the actual code of the startup file used in this example:</h5>



                        <div class="box">
                            <img src="images/makefile_1.png">
                        </div>

                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:2]</td>
                                    <td>Here we assign the CC macro with the name of the arm cross compiler</td>
                                </tr>
                                <tr>
                                    <td>[Line:5-9]</td>
                                    <td>This macros are used to assign names to the directories used in this project. This is specific to this example and can be configured to suit the project's needs.</td>
                                </tr>
                                <tr>
                                    <td>[Line:12-13]</td>
                                    <td>Using the wildcard feature of "make" we assign all the c file names to one single macro, which we can later use during compilation</td>
                                </tr>
                                <tr>
                                    <td>[Line:14-15]</td>
                                    <td>Here the values assigned to the SRC macros are substituted with a .o exten using the patsubst feature. Furthermore, its file paths have been changed with that of the directory make for object files. This also is specific to this project.</td>
                                </tr>
                                <tr>
                                    <td>[Line:16]</td>
                                    <td>Lastly the macro LD is used to hold the name of our linker script</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="box">
                            <img src="images/makefile_2.png">
                        </div>

                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:19]</td>
                                    <td>The MARCH macro is the processor used for this project. This will later be used during compilation</td>
                                </tr>
                                <tr>
                                    <td>[Line:20]</td>
                                    <td>These are the flags used during compilation. -g is used to generate debugging information. -Wall is an option used by the compiler to generate warnings. -mcpu and -mthumb tell the compiler which cpu is used and that thumb instructions are used. -mfloat-abi=soft tells the compiler, that floating functionalities will be enabled by a software implementation. -I tells the compiler where to look for include files, in this project this is used, as the Peripherals have been implemented using structs which are placed in the include directory.</td>
                                </tr>
                                <tr>
                                    <td>[Line:21]</td>
                                    <td>These are the linker flags. -nostdlib means no standard library functions are used that need to be linked. -T tells the linker where to search for the linker script. -Wl, tells the linker that linker options are being passed. -Map is used to generate a map file of the executable which is very helpful for debugging purposes.</td>
                                </tr>
                                <tr>
                                    <td>[Line:24-25]</td>
                                    <td>These are the paths to the openOCD scripts used to tell openOCD how to connect and communicate with the on chip ST-Link V2 debugger, as well as the debugger unit on the STM32F401RE.</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="box">
                            <img src="images/makefile_3.png">
                        </div>

                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:28]</td>
                                    <td>The TARGET is the macro used for our ELF executable</td>
                                </tr>
                                <tr>
                                    <td>[Line:30]</td>
                                    <td>In case "make" is executed by the default all files and targets specified after this keyword will be generated</td>
                                </tr>
                                <tr>
                                    <td>[Line:32-36]</td>
                                    <td>These are makefile rules, telling make to generate object files using the c source files. If the Object file directory is not present, the "mkobj" target is called which will create a directory needed for compilation</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="box">
                            <img src="images/makefile_4.png">
                        </div>

                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>

                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="blinky">Blinky - Project</a></h2>
If you're working on register level programming for an embedded system, one thing you might want to consider is using struct pointers that are assigned with fixed addresses. This can be helpful in a number of ways. For one, it can make your code more readable. When you're working with a lot of registers, it can be difficult to keep track of what each one is used for. But if you give each register a meaningful name and then access it through a pointer, it can be much easier to understand what your code is doing. Another advantage is that it can make your code more efficient. If you know the address of a register, you can directly access it without having to go through any intermediate steps. This can be a significant speed boost, especially if you're working with time-critical code.

</br></br></br>A peripheral can be defined using a struct with each of its registers initialized as the struct's members. The following code is the struct data structure of the STM32F401RE GPIO Peripheral.
                        <div class="box">
                            <img src="images/gpio_struct.png">
                        </div>
                        Now that the registers have been initialized, an instance of that struct can be assigned a fixed address from the system's memory, defined in the reference manual. A possible method is to instantiate a struct pointer which is then assigned an address, as illustrated by the following code:
                        <pre>
                            <code>STRUCT_NAME * const defined_instance = (STRUCT_NAME *) ADDRESS;</code>
                        </pre>
                        To instantiate the GPIO Peripheral from the previously shown GPIOx_t using this method, we can now write:
                        <pre>
                            <code>GPIOx_t * const GPIOA = (GPIOx_t *)0x40020000; // This address is specific to STM32F401RE</code>
                        </pre>
This code instantiates struct pointers with the pointer being constant, meaning the address should not be changed. However, the value of the address the pointer is pointing to can be accessed and manipulated, which is what we want for our purposes.
                        </br></br>

                        <h5>The following code contains the actual code of the startup file used in this example:</h5>
                        <div class="box">
                            <img src="images/simple_blink_proj_main.png">
                        </div>


                        <table class="table table-striped table-bordered">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Description of the code above:</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>[Line:1]</td>
                                    <td>The macro pin5 is later used to configure and manipulate the Pin 5 of GPIOA</td>
                                </tr>
                                <tr>
                                    <td>[Line:2]</td>
                                    <td>The MODER Register is part of the GPIO Port which is later used to configure a pin either input, output or even assign an alternate function. As the width of MODER is a 2 Bit Bitfield, this value is used for a more readable code</td>
                                </tr>
                                <tr>
                                    <td>[Line:5-6]</td>
                                    <td>Here struct pointers of the RCC Peripheral (used to handle Clock Enabling in this example) and GPIOA Port is initialized and assigned with their associated fixed addresses in memory (This can be looked up in the reference manual under the "memory map" section)</td>
                                </tr>
                                <tr>
                                    <td>[Line:9-13]</td>
                                    <td>This is a simple delay function implementation generating an approximately 1ms delay every 1600 Clock Cycles with a 16MHz internal clock, which can generating the desired ms delay by looping the inner-for-loop by the amount of times certain ms are passed to the function</td>
                                </tr>
                                <tr>
                                    <td>[Line:21]</td>
                                    <td>One of the great features of the STM32 is its clock gating feature, which allows peripherals to save power when they are not in use. In a nutshell, clock gating is a power-saving technique that stops the clock signal to a particular circuit when that circuit is not in use. This prevents the circuit from wasting power by doing unnecessary work. In order to enable that peripheral we need to enable it using the Reset Clock Control Peripheral of the microcontroller. Using the AHB1ENR Register GPIOA is enabled by writing a 1 to that specific bit associated with that peripheral.</td>
                                </tr>
                            </tbody>
                        </table>


                        <h2 class="code-line" data-line-start=25 data-line-end=26><a id="share_repo">Code and Documentation</a></h2>
                        If you're interested in seeing how this project was made, please check out the source code and documentation. All the code is available for you to view, and the documentation goes into detail about how everything works. Thanks for your interest!</br></br>

                        <div class="col-12" >
                            <ul class="actions">
                                <li><a href="https://github.com/jbvalle/011_bare_metal_STM32F401RE_basic_setup" target="_blank" class="button primary">Github</a></li>
                                <li><a href="https://jbvalle.github.io/011_bare_metal_STM32F401RE_basic_setup/" target="_blank" class="button">Documentation</a></li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Footer -->
                <footer id="footer">
                    <ul class="icons">
                        <li><a href="https://twitter.com/JbvalleJv" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
                        <li><a href="https://www.linkedin.com/in/johnbryanvalle/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
                        <li><a href="https://github.com/jbvalle" class="icon brands fa-github"><span class="label">Github</span></a></li>
                        <li><a href="mailto:jbvalle.jv@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
                    </ul>
                    <ul class="copyright">
                        <li>&copy; John Bryan Valle</li>
                    </ul>
                </footer>

        </div>

        <!-- Scripts -->
        <script src="assets/js/jquery.min.js"></script>
        <script src="assets/js/jquery.scrollex.min.js"></script>
        <script src="assets/js/jquery.scrolly.min.js"></script>
        <script src="assets/js/browser.min.js"></script>
        <script src="assets/js/breakpoints.min.js"></script>
        <script src="assets/js/util.js"></script>
        <script src="assets/js/main.js"></script>


    </body>




</html>
